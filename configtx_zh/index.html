<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Hyperledger国际化工作组">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Channel 配置(configtx) - Hyperledger中文文档</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Channel \u914d\u7f6e(configtx)";
    var mkdocs_page_input_path = "configtx_zh.md";
    var mkdocs_page_url = "/configtx_zh/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Hyperledger中文文档</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">欢迎</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../glossary/">词汇表</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../blockchain_zh/">简介</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../getting_started/">快速入门</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../protocol-spec_zh/">协议规范</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric教程</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../build_network_zh/">构建第一个fabric网络</a>
                </li>
                <li class="">
                    
    <a class="" href="../write_first_app_zh/">编写第一个应用</a>
                </li>
                <li class="">
                    
    <a class="" href="../channel_update_zh/">重新配置第一个网络</a>
                </li>
                <li class="">
                    
    <a class="" href="../chaincode_zh/">Chaincode 指南</a>
                </li>
                <li class="">
                    
    <a class="" href="../chaincode_developers_zh/">Chaincode 开发手册</a>
                </li>
                <li class="">
                    
    <a class="" href="../chaincode_operators_zh/">Chaincode 操作手册</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric操作指南</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../msp_zh/">MSP</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Channel 配置(configtx)</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#configtx">通道配置(configtx)</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#_1">解剖一个配置</a></li>
        
            <li><a class="toctree-l4" href="#_2">配置更新</a></li>
        
            <li><a class="toctree-l4" href="#groupvalue">允许的配置组(group)和值(value)</a></li>
        
            <li><a class="toctree-l4" href="#_3">排序系统通道配置</a></li>
        
            <li><a class="toctree-l4" href="#_4">应用通道配置</a></li>
        
            <li><a class="toctree-l4" href="#_5">通道创建</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../configtxgen_zh/">Channel 配置(configtxgen)</a>
                </li>
                <li class="">
                    
    <a class="" href="../configtxlator_zh/">Channel 重新配置(configtxlator)</a>
                </li>
                <li class="">
                    
    <a class="" href="../endorsement-policies_zh/">背书策略</a>
                </li>
                <li class="">
                    
    <a class="" href="../error-handling_zh/">错误处理</a>
                </li>
                <li class="">
                    
    <a class="" href="../logging-control_zh/">日志控制</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric设计</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../arch-deep-dive_zh/">架构说明</a>
                </li>
                <li class="">
                    
    <a class="" href="../txflow_zh/">交易流程</a>
                </li>
                <li class="">
                    
    <a class="" href="../ca-setup_zh/">CA</a>
                </li>
                <li class="">
                    
    <a class="" href="../sdk_node_zh/">SDK--node</a>
                </li>
                <li class="">
                    
    <a class="" href="../sdk_java_zh/">SDK--java</a>
                </li>
                <li class="">
                    
    <a class="" href="../kafka_zh/">基于kafka的排序服务</a>
                </li>
                <li class="">
                    
    <a class="" href="../channels_zh/">Channels</a>
                </li>
                <li class="">
                    
    <a class="" href="../ledger_zh/">账本</a>
                </li>
                <li class="">
                    
    <a class="" href="../read-write-set/">Read-Write set</a>
                </li>
                <li class="">
                    
    <a class="" href="../gossip_zh/">Gossip数据传输协议</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">故障排除和常见问题</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../Fabric-FAQ/">Hyperledger Fabric 答疑</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../msp_acl_zh/">MSP&ACL</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../sdk-design_zh/">Fabric SDK 设计</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../makefile_zh/">Makefile文件解析</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../blockchain-crypto-service-provider_zh/">BCCSP密码算法套件解析</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../zanata_guide/">Zanata使用指南</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hyperledger中文文档</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Fabric操作指南 &raquo;</li>
        
      
    
    <li>Channel 配置(configtx)</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/HyperledgerCN/hyperledgerDocs/edit/master/docs/configtx_zh.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="configtx">通道配置(configtx)<a class="headerlink" href="#configtx" title="Permanent link">&para;</a></h2>
<p><a href="http://hyperledger-fabric.readthedocs.io/en/latest/configtx.html">原文</a><br />
Hyperledger Fabric区块链网络的共享配置被保存在一个配置交易集合中，每个通道一个。每个配置交易通常叫做<em>configtx</em>。<br />
通道配置有如下重要属性：
1. 版本(<strong>Versioned</strong>)：配置的所有元素都有一个关联的版本，每次修改都会更新。此外，每次更新配置都会收到一个顺序号。<br />
2. 权限(<strong>Permissioned</strong>)：配置的每个元素有一个关联的策略，用于管理是否允许对该元素进行修改。任何拥有以前configtx副本（并且没有其他信息）的人都可以根据这些策略验证新配置的有效性。
3. 层次(<strong>Hierarchical</strong>)：根配置组包含子组，每个层次组都有关联的值和策略。这些政策可以利用层次结构从下层策略中推导出一个层次的策略。</p>
<h3 id="_1">解剖一个配置<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>配置被保存在区块的一个类型为<code>HeaderType_CONFIG</code>的交易中，该区块中没有其他交易。这些区块被称为<strong>配置区块</strong>，第一个区块被称为<strong>创世区块</strong>(Genesis Block)。<br />
配置的proto结构存储在<code>fabric/protos/common/configtx.proto</code>。封装类型<code>HeaderType_CONFIG</code>编码了一个<code>ConfigEnvelope</code>消息，作为<code>Payload``data</code>字段。<code>ConfigEnvelope</code>的proto定义如下：</p>
<pre><code class="golang">message ConfigEnvelope {
    Config config = 1;
    Envelope last_update = 2;
}
</code></pre>

<p>(上面的<code>1``2</code>是go语言结构的属性tag)<br />
<code>last_update</code>字段定义在下面的<strong>Updates to configuration</strong>部分，但仅在验证配置时需要，不会读它。相反，当前提交的配置被存储在<code>config</code>字段，其中包含了一个<code>Config</code>消息。</p>
<pre><code class="golang">message Config {
    uint64 sequence = 1;
    ConfigGroup channel_group = 2;
}
</code></pre>

<p><code>sequence</code>数字在每次配置提交后会增长。<code>channel_group</code>字段是包含配置的根组(root group)。。<code>ConfigGroup</code>结构是递归定义的，构建了一个组数，它可以包含值和策略。它是如下定义的：</p>
<pre><code class="golang">message ConfigGroup {
    uint64 version = 1;
    map&lt;string,ConfigGroup&gt; groups = 2;
    map&lt;string,ConfigValue&gt; values = 3;
    map&lt;string,ConfigPolicy&gt; policies = 4;
    string mod_policy = 5;
}
</code></pre>

<p>因为<code>ConfigGroup</code>是个递归结构，它是按层次整理的。下面的例子是用go语言符号表示的。</p>
<pre><code class="golang">// Assume the following groups are defined
var root, child1, child2, grandChild1, grandChild2, grandChild3 *ConfigGroup

// Set the following values
root.Groups[&quot;child1&quot;] = child1
root.Groups[&quot;child2&quot;] = child2
child1.Groups[&quot;grandChild1&quot;] = grandChild1
child2.Groups[&quot;grandChild2&quot;] = grandChild2
child2.Groups[&quot;grandChild3&quot;] = grandChild3

// The resulting config structure of groups looks like:
// root:
//     child1:
//         grandChild1
//     child2:
//         grandChild2
//         grandChild3
</code></pre>

<p>每个组在配置层次上定义了一个级别，每个组都有一组关联的值（由字符串类型的key索引）和策略（也由字符串类型的key索引）。  </p>
<p>Value被下列结构定义：</p>
<pre><code class="golang">message ConfigValue {
    uint64 version = 1;
    bytes value = 2;
    string mod_policy = 3;
}
</code></pre>

<p>Policy由下列结构定义：</p>
<pre><code class="golang">message ConfigPolicy {
    uint64 version = 1;
    Policy policy = 2;
    string mod_policy = 3;
}
</code></pre>

<p>请注意，Value、Policy和Group都有一个<code>version</code>和一个<code>mod_policy</code>。元素的<code>version</code>的值会在元素被修改时递增。<code>mod_policy</code>用来管理修改元素所需的签名。</p>
<p>对于Group，修改就是向Value、Policy或Group映射中添加或删除元素（或更改<code>mod_policy</code>）。对于Value和Policy，修改就是分别改变Value和Policy字段（或改变<code>mod_policy</code>）。</p>
<p>每个元素的<code>mod_policy</code>都在当前配置级别的上下文中进行评估。考虑在下面例子的<code>mod_policy</code>定义在<code>Channel.Groups["Application"]</code>（在这里，我们使用golang映射引用语法，所以<code>Channel.Groups["Application"].Policies["policy1"]</code>引用了基础<code>Channel</code>组的<code>Application</code>组的<code>Policies</code>映射的<code>policy1</code>策略。）</p>
<ul>
<li><code>policy1</code>映射到<code>Channel.Groups["Application"].Policies["policy1"]</code>  </li>
<li><code>Org1/policy2</code>映射到<code>Channel.Groups["Application"].Groups["Org1"].Policies["policy2"]</code>  </li>
<li><code>/Channel/policy3</code>映射到<code>Channel.Policies["policy3"]</code>  </li>
</ul>
<p>请注意，如果<code>mod_policy</code>引用了一个不存在的策略，则该项目不会被修改。  </p>
<h3 id="_2">配置更新<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>配置更新会递交一个<code>HeaderType_CONFIG_UPDAT</code>类型的<code>Envelope</code>消息。交易的<code>Payload``data</code>是一个marshaled<code>ConfigUpdateEnvelope</code>。<code>ConfigUpdateEnvelope</code>的定义如下：</p>
<pre><code class="golan">message ConfigUpdateEnvelope {
    bytes config_update = 1;
    repeated ConfigSignature signatures = 2;
}
</code></pre>

<p>签名字段包含了一组授权配置更新的签名。它的消息定义是：</p>
<pre><code class="golang">message ConfigSignature {
    bytes signature_header = 1;
    bytes signature = 2;
}
</code></pre>

<p><code>signature_header</code>是标准交易的定义，而<code>signature</code>是<code>signature_header</code>字节和<code>ConfigUpdateEnvelope</code>消息的<code>config_update</code>字节串连后的签名。</p>
<p><code>ConfigUpdateEnvelope</code>的<code>config_update</code>字节是一个marshaled<code>ConfigUpdate</code>消息，该消息定义如下：</p>
<pre><code class="golang">message ConfigUpdate {
    string channel_id = 1;
    ConfigGroup read_set = 2;
    ConfigGroup write_set = 3;
}
</code></pre>

<p>这<code>channel_id</code>是更新要绑定的通道ID，这对于限定此重新配置的签名范围是必要的。</p>
<p>在<code>read_set</code>指定了现有的配置的一个子集，它暗示了只有<code>version</code>字段必须提供的，而且字段是可选则。字段<code>ConfigValue``value</code>或 <code>ConfigPolicy``policy</code>不允许出现在<code>read_set</code>。<code>ConfigGroup</code>可以填充它映射字段的子集，以便引用在配置树更深的元素。例如，要<code>read_set</code>中包括<code>Application</code>组，则它的母元素（该<code>Channel</code>组）也必须包含在<code>read_set</code>中，但是，该<code>Channel</code>组并不需要填充所有的key，如<code>Orderer``group</code>key，或任何<code>values</code>或<code>policies</code>key。</p>
<p><code>write_set</code>定义了配置的被修改部分。由于配置的层次性，对层次结构中深层元素的写入操作也必须在<code>write_set</code>从包含其更高层次的元素。但是，对于<code>write_set</code>中任何元素，如果也出现在<code>read_set</code>中且版本相同，则会被更新忽略（？）。</p>
<p>例如，对于给定配置：</p>
<pre><code>Channel: (version 0)
    Orderer (version 0)
    Appplication (version 3)
       Org1 (version 2)
</code></pre>

<p>去递交一个改变<code>Org1</code>的配置更新，<code>read_set</code>会是：</p>
<pre><code>Channel: (version 0)
    Application: (version 3)
</code></pre>

<p>而它的<code>write_set</code>会是：</p>
<pre><code>Channel: (version 0)
    Application: (version 3)
        Org1 (version 3)
</code></pre>

<p>当收到<code>CONFIG_UPDATE</code>，orderer会按下面的步骤计算结果集<code>CONFIG</code>：
1. 检验<code>channel_id</code>和<code>read_set</code>。所有<code>read_set</code>中元素必须存在且版本号相同。<br />
2. 通过比较存在于<code>write_set</code>中而不存在于<code>read_set</code>中且版本号相同的元素，得到更新元素集。<br />
3. 检验更新元素集中的元素版本号，确保只增长了1。<br />
4. 对更新元素集中的每个元素，检验针对<code>ConfigUpdateEnvelope</code>的签名集，确保符合<code>mod_policy</code>。<br />
5. 通过将更新集应用到当前配置，计算出配置的一个新完全版本。<br />
6. 将新配置写入<code>ConfigEnvelope</code>，将<code>CONFIG_UPDATE</code>作为<code>the last_update</code>字段，并与增长的<code>sequence</code>值一起将新配置编码入<code>config</code>字段。<br />
7. 将一个新的<code>ConfigEnvelope</code>以类型<code>CONFIG</code>写入<code>Envelope</code>，最后将这个作为唯一交易写入一个新配置区块。  </p>
<p>当新的peer(或任何其他的<code>Deliver</code>接收者)接收到这个配置区块，它会校验这个配置，方法是将<code>last_update</code>消息应用到当前配置，确保orderer计算出来的<code>config</code>字段包含了正确的新配置。  </p>
<h3 id="groupvalue">允许的配置组(group)和值(value)<a class="headerlink" href="#groupvalue" title="Permanent link">&para;</a></h3>
<p>任何有效的配置都是下面配置的子集。这里我们使用符号<code>peer.&lt;MSG&gt;</code>来定义一个<code>ConfigValue</code>，它的<code>value</code>字段是一个名为<code>&lt;MSG&gt;</code>的marshaled proto消息（定义在<code>fabric/protos/peer/configuration.proto</code>）。符号<code>common.&lt;MSG&gt;</code>、<code>msp.&lt;MSG&gt;</code>和<code>orderer.&lt;MSG&gt;</code>含义类似，只是它们的消息分别定义在<code>fabric/protos/common/configuration.proto</code>、<code>fabric/protos/msp/mspconfig.proto</code>和<code>fabric/protos/orderer/configuration.proto</code>。  </p>
<p>需要注意的是key<code>{{org_name}}</code>和<code>{{consortium_name}}</code>可以是任意名字，这表明一个元素可以以任何名字重复出现。  </p>
<pre><code class="golang">&amp;ConfigGroup{
    Groups: map&lt;string, *ConfigGroup&gt; {
        &quot;Application&quot;:&amp;ConfigGroup{
            Groups:map&lt;String, *ConfigGroup&gt; {
                {{org_name}}:&amp;ConfigGroup{
                    Values:map&lt;string, *ConfigValue&gt;{
                        &quot;MSP&quot;:msp.MSPConfig,
                        &quot;AnchorPeers&quot;:peer.AnchorPeers,
                    },
                },
            },
        },
        &quot;Orderer&quot;:&amp;ConfigGroup{
            Groups:map&lt;String, *ConfigGroup&gt; {
                {{org_name}}:&amp;ConfigGroup{
                    Values:map&lt;string, *ConfigValue&gt;{
                        &quot;MSP&quot;:msp.MSPConfig,
                    },
                },
            },

            Values:map&lt;string, *ConfigValue&gt; {
                &quot;ConsensusType&quot;:orderer.ConsensusType,
                &quot;BatchSize&quot;:orderer.BatchSize,
                &quot;BatchTimeout&quot;:orderer.BatchTimeout,
                &quot;KafkaBrokers&quot;:orderer.KafkaBrokers,
            },
        },
        &quot;Consortiums&quot;:&amp;ConfigGroup{
            Groups:map&lt;String, *ConfigGroup&gt; {
                {{consortium_name}}:&amp;ConfigGroup{
                    Groups:map&lt;string, *ConfigGroup&gt; {
                        {{org_name}}:&amp;ConfigGroup{
                            Values:map&lt;string, *ConfigValue&gt;{
                                &quot;MSP&quot;:msp.MSPConfig,
                            },
                        },
                    },
                    Values:map&lt;string, *ConfigValue&gt; {
                        &quot;ChannelCreationPolicy&quot;:common.Policy,
                    }
                },
            },
        },
    },

    Values: map&lt;string, *ConfigValue&gt; {
        &quot;HashingAlgorithm&quot;:common.HashingAlgorithm,
        &quot;BlockHashingDataStructure&quot;:common.BlockDataHashingStructure,
        &quot;Consortium&quot;:common.Consortium,
        &quot;OrdererAddresses&quot;:common.OrdererAddresses,
    },
}
</code></pre>

<h3 id="_3">排序系统通道配置<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>排序系统通道需要定义排序参数，和创建通道的联盟。对一个排序服务必须存在一个排序系统通道，它是创建的第一个通道（更准确地说是引导时创建）。建议不要在排序系统通道的创世配置中定义应用部分（的通道），但可以在测试时这样做。注意，对排序系统通道具有读权限的成员可以看到所有通道（系统的和应用的所有通道）的创建，所以这个通道的访问权限需要严格控制。</p>
<p>排序参数用下面配置的子集来定义：</p>
<pre><code class="golang">&amp;ConfigGroup{
    Groups: map&lt;string, *ConfigGroup&gt; {
        &quot;Orderer&quot;:&amp;ConfigGroup{
            Groups:map&lt;String, *ConfigGroup&gt; {
                {{org_name}}:&amp;ConfigGroup{
                    Values:map&lt;string, *ConfigValue&gt;{
                        &quot;MSP&quot;:msp.MSPConfig,
                    },
                },
            },

            Values:map&lt;string, *ConfigValue&gt; {
                &quot;ConsensusType&quot;:orderer.ConsensusType,
                &quot;BatchSize&quot;:orderer.BatchSize,
                &quot;BatchTimeout&quot;:orderer.BatchTimeout,
                &quot;KafkaBrokers&quot;:orderer.KafkaBrokers,
            },
        },
    },
</code></pre>

<p>参与排序的每个组织在<code>Orderer</code>组下都有一个组元素。这个组定义一个<code>MSP</code>参数，它包含了组织的密钥id信息。<code>Orderer</code>组的<code>Values</code>确定了排序节点的功能。它们存在于每个通道，所以实例的<code>orderer.BatchTimeout</code>可以在不同的通道定义不同的值。</p>
<p>启动时，orderer会面对一个包含了多个通道信息的文件系统。orderer根据联盟组通道定义出系统通道。联盟组具有下面的结构：</p>
<pre><code class="golang">&amp;ConfigGroup{
    Groups: map&lt;string, *ConfigGroup&gt; {
        &quot;Consortiums&quot;:&amp;ConfigGroup{
            Groups:map&lt;String, *ConfigGroup&gt; {
                {{consortium_name}}:&amp;ConfigGroup{
                    Groups:map&lt;string, *ConfigGroup&gt; {
                        {{org_name}}:&amp;ConfigGroup{
                            Values:map&lt;string, *ConfigValue&gt;{
                                &quot;MSP&quot;:msp.MSPConfig,
                            },
                        },
                    },
                    Values:map&lt;string, *ConfigValue&gt; {
                        &quot;ChannelCreationPolicy&quot;:common.Policy,
                    }
                },
            },
        },
    },
},
</code></pre>

<p>注意，每个联盟定义了一组成员，就像排序组织成员一样。每个联盟还定义了一个ChannelCreationPolicy。这个策略用于对通道创建请求进行授权。通常，这个值被设为<code>ImplicitMetaPolicy</code>，意思是要求通道的新成员签名以授权频道创建(个人理解：打算创建一个包含N个组织的通道，那么这N个组织都得签名，每个组织都有否决权，有组织不同意，新通道就建不起来)。关于通道创建的更多内容在文章的后面还有。</p>
<h3 id="_4">应用通道配置<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>通道的应用配置被设计用于应用类型的交易。它的定义如下：</p>
<pre><code class="golang">&amp;ConfigGroup{
    Groups: map&lt;string, *ConfigGroup&gt; {
        &quot;Application&quot;:&amp;ConfigGroup{
            Groups:map&lt;String, *ConfigGroup&gt; {
                {{org_name}}:&amp;ConfigGroup{
                    Values:map&lt;string, *ConfigValue&gt;{
                        &quot;MSP&quot;:msp.MSPConfig,
                        &quot;AnchorPeers&quot;:peer.AnchorPeers,
                    },
                },
            },
        },
    },
}
</code></pre>

<p>很像<code>Orderer</code>部分，每个组织被编码为一个组(group)。然而，不仅仅编码了<code>MSP</code>id信息，每个组织附加编码了一个<code>AnchorPeers</code>列表。这是一个允许不同组织之间通过peer gossip网络互相联系的peer列表（这个列表中的peer才可以被其他组织的peer“看到”）。</p>
<p>应用通道编码了一个orderer组织的副本，和用于确定变更这些参数的共识选项，所以包含了系统通道配置的<code>Orderer</code>部分的相同内容。然而，从应用的观点这可以被大大忽略。  </p>
<h3 id="_5">通道创建<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>当排序节点收到一个不存在的通道的<code>CONFIG_UPDATE</code>，排序节点就假定这是个通道创建请求，然后执行下列操作：
1. orderer确定发出通道创建请求的联盟身份。它通过查看顶层group的<code>Consortium</code>值来做到这一点。<br />
2. orderer验证包含在<code>Application</code>组的组织，确保这些组织是联盟下属(子集)，而且<code>ApplicationGroup</code>被设置为<code>version``1</code>。<br />
3. orderer验证联盟是否有成员，从而新通道会有应用成员(创建没有成员的联盟和通道仅用于测试)。<br />
4. orderer通过从排序系统通道中取得<code>Orderer</code>组来创建一个模板配置，用新的成员创建一个<code>Application</code>组并指定<code>mod_policy</code>为联盟配置里的<code>ChannelCreationPolicy</code>。需要注意的是策略是在新配置的上下文中被评估的，所以一个需要<code>ALL</code>成员的策略仅需要全部新通道成员的签名，而不是联盟的所有成员签名。<br />
5. orderer将<code>CONFIG_UPDATE</code>作为一个更新应用到这个模板配置。因为这个<code>CONFIG_UPDATE</code>应用变更到<code>Application</code>组(它的<code>version</code>是<code>1</code>)，配置代码用<code>ChannelCreationPolicy</code>验证这些更新。如果通道创建包含其他变更，如个别组织的锚peer，元素的相应mod policy会被调用。<br />
6. 为了排序，含有新通道配置的新<code>CONFIG</code>交易会被包装和发送到排序系统通道。排序后，通道就创建了。  </p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../configtxgen_zh/" class="btn btn-neutral float-right" title="Channel 配置(configtxgen)">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../msp_zh/" class="btn btn-neutral" title="MSP"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Hyperledger国际化工作组(yls@chainnova.com)</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/HyperledgerCN/hyperledgerDocs/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../msp_zh/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../configtxgen_zh/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js"></script>
      <script src="../search/require.js"></script>
      <script src="../search/search.js"></script>

</body>
</html>
