<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Hyperledger国际化工作组">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>构建第一个fabric网络 - Hyperledger中文文档</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u6784\u5efa\u7b2c\u4e00\u4e2afabric\u7f51\u7edc";
    var mkdocs_page_input_path = "build_network_zh.md";
    var mkdocs_page_url = "/build_network_zh/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Hyperledger中文文档</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">欢迎</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../glossary/">词汇表</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../blockchain_zh/">简介</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../getting_started/">快速入门</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../protocol-spec_zh/">协议规范</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric教程</span>
    <ul class="subnav">
                <li class=" current">
                    
    <a class="current" href="./">构建第一个fabric网络</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#first-network">启动首个网络(first-network)</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#_1">生成网络工件</a></li>
        
            <li><a class="toctree-l4" href="#_2">启动网络</a></li>
        
            <li><a class="toctree-l4" href="#_3">停止网络</a></li>
        
            <li><a class="toctree-l4" href="#crypto-generator">密钥生成器(Crypto Generator)</a></li>
        
            <li><a class="toctree-l4" href="#_5">配置事务生成器</a></li>
        
            <li><a class="toctree-l4" href="#_7">运行工具</a></li>
        
            <li><a class="toctree-l4" href="#_10">启动网络</a></li>
        
            <li><a class="toctree-l4" href="#docker-comopse">理解docker-comopse拓扑</a></li>
        
            <li><a class="toctree-l4" href="#couchdb">使用CouchDB</a></li>
        
            <li><a class="toctree-l4" href="#couchdb_1">为什么是CouchDB？</a></li>
        
            <li><a class="toctree-l4" href="#_18">一个关于数据持久化的备注</a></li>
        
            <li><a class="toctree-l4" href="#troubleshooting">Troubleshooting</a></li>
        
            <li><a class="toctree-l4" href="#fabric">理解Fabric网络</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../write_first_app_zh/">编写第一个应用</a>
                </li>
                <li class="">
                    
    <a class="" href="../channel_update_zh/">重新配置第一个网络</a>
                </li>
                <li class="">
                    
    <a class="" href="../chaincode_zh/">Chaincode 指南</a>
                </li>
                <li class="">
                    
    <a class="" href="../chaincode_developers_zh/">Chaincode 开发手册</a>
                </li>
                <li class="">
                    
    <a class="" href="../chaincode_operators_zh/">Chaincode 操作手册</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric操作指南</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../msp_zh/">MSP</a>
                </li>
                <li class="">
                    
    <a class="" href="../configtx_zh/">Channel 配置(configtx)</a>
                </li>
                <li class="">
                    
    <a class="" href="../configtxgen_zh/">Channel 配置(configtxgen)</a>
                </li>
                <li class="">
                    
    <a class="" href="../configtxlator_zh/">Channel 重新配置(configtxlator)</a>
                </li>
                <li class="">
                    
    <a class="" href="../endorsement-policies_zh/">背书策略</a>
                </li>
                <li class="">
                    
    <a class="" href="../error-handling_zh/">错误处理</a>
                </li>
                <li class="">
                    
    <a class="" href="../logging-control_zh/">日志控制</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric设计</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../arch-deep-dive_zh/">架构说明</a>
                </li>
                <li class="">
                    
    <a class="" href="../txflow_zh/">交易流程</a>
                </li>
                <li class="">
                    
    <a class="" href="../ca-setup_zh/">CA</a>
                </li>
                <li class="">
                    
    <a class="" href="../sdk_node_zh/">SDK--node</a>
                </li>
                <li class="">
                    
    <a class="" href="../sdk_java_zh/">SDK--java</a>
                </li>
                <li class="">
                    
    <a class="" href="../kafka_zh/">基于kafka的排序服务</a>
                </li>
                <li class="">
                    
    <a class="" href="../channels_zh/">Channels</a>
                </li>
                <li class="">
                    
    <a class="" href="../ledger_zh/">账本</a>
                </li>
                <li class="">
                    
    <a class="" href="../read-write-set/">Read-Write set</a>
                </li>
                <li class="">
                    
    <a class="" href="../gossip_zh/">Gossip数据传输协议</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">故障排除和常见问题</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../Fabric-FAQ/">Hyperledger Fabric 答疑</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../msp_acl_zh/">MSP&ACL</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../sdk-design_zh/">Fabric SDK 设计</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../makefile_zh/">Makefile文件解析</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../blockchain-crypto-service-provider_zh/">BCCSP密码算法套件解析</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../zanata_guide/">Zanata使用指南</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hyperledger中文文档</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Fabric教程 &raquo;</li>
        
      
    
    <li>构建第一个fabric网络</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/HyperledgerCN/hyperledgerDocs/edit/master/docs/build_network_zh.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">原文</a>  </p>
<h2 id="first-network">启动首个网络(first-network)<a class="headerlink" href="#first-network" title="Permanent link">&para;</a></h2>
<p>本节遵循hyperledger官方文档“<a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">Building Your First Network</a><br />
first-network提供了一个脚本来帮助初学者体验fabric，它就是<code>byfn.sh</code>。可以通过帮助命令看看它的功能：</p>
<pre><code>$ cd /opt/fabric-samples/first-network
$ ./byfn.sh --help
 byfn.sh -m up|down|restart|generate [-c &lt;channel name&gt;] [-t &lt;timeout&gt;] [-d &lt;delay&gt;] [-f &lt;docker-compose-file&gt;] [-s &lt;dbtype&gt;]
</code></pre>

<h3 id="_1">生成网络工件<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>generate required certificates and genesis block
fabric的网络和通道具有类似的含义。通道可以视为一种虚拟网络，多个通道就多个虚拟网络。docker支持overlay网络，为同一个peer加入不同的网络创造了底层技术基础（以上认识还没有得到确认）。</p>
<pre><code>$ ./byfn.sh -m generate
Generating certs and genesis block for with channel 'mychannel' and CLI timeout of '10000'
Continue (y/n)?y
(后略)
</code></pre>

<p><code>byfn.sh</code>会在屏幕上有很多输出，通过这些文字也可以知道该脚本的功能：
1. 生成了Orderer的创世区块。在排序节点上fabric维护了一个“系统账本”，保存了整个fabric区块链网络的参数、元数据等。对于区块链来说，第一个块(有时称0号区块)被称为创世区块(Genesis block)。该创世区块对应了一个文件，一般是<code>genesis.block</code>。<br />
2. 创建了一个通道。生成了一个叫<code>channel.tx</code>的文件。<br />
3. 生成了组织Org1MSP和Org2MSP的锚peer。锚peer用于跨组织的通信。  </p>
<h3 id="_2">启动网络<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<pre><code>$ ./byfn.sh -m up
（适当删减）
Channel &quot;mychannel&quot; is created successfully =====================
PEER0 joined on the channel &quot;mychannel&quot; =====================
PEER1 joined on the channel &quot;mychannel&quot; =====================
PEER2 joined on the channel &quot;mychannel&quot; =====================
PEER3 joined on the channel &quot;mychannel&quot; =====================
Anchor peers for org &quot;Org1MSP&quot; on &quot;mychannel&quot; is updated successfully =====================
Anchor peers for org &quot;Org2MSP&quot; on &quot;mychannel&quot; is updated successfully =====================
Chaincode is installed on remote peer PEER0 =====================
Chaincode is installed on remote peer PEER2 =====================
Chaincode Instantiation on PEER2 on channel 'mychannel' is successful =====================
Querying on PEER0 on channel 'mychannel'... =====================
Invoke transaction on PEER0 on channel 'mychannel' is successful =====================
Chaincode is installed on remote peer PEER3 =====================
Querying on PEER3 on channel 'mychannel'... =====================
========= All GOOD, BYFN execution completed ===========
</code></pre>

<p>启动后屏幕仍被锁定为日志输出，可以打开另外的终端窗口进行后续的操作。如，查看容器清单：</p>
<pre><code>$ docker ps
</code></pre>

<p>可以看到容器有：
1. cli(fabric-tools)，是fabric的命令行工具<br />
2. peer0.org1.example.com等(fabric-peer)，是peer节点的进程容器<br />
3. orderer.example.com(fabric-orderer)，是orderer节点的进程容器<br />
4. dev-peer0.org1.example.com-mycc-1.0-xxxx， 是链码容器
在其他的fabric环境中(如生产环境下)，还可能看到ca-server的容器、couchdb的容器等。  </p>
<h3 id="_3">停止网络<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<pre><code>$ ./byfn.sh -m down
$ docker ps
</code></pre>

<p>网络停止后，通过docker ps命令可以看到所有的容器都消失了。</p>
<h3 id="crypto-generator">密钥生成器(Crypto Generator)<a class="headerlink" href="#crypto-generator" title="Permanent link">&para;</a></h3>
<p>我们用<code>cryptogen</code>工具为各种的网络实体生成密码学文件(x509证书和签名密钥)。这些证书表达身份，对实体间通信和事务认证进行签名和验证。  </p>
<h4 id="_4">它是如何工作的？<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<p>Cryptogen的配置文件是<code>crypto-config.yaml</code>，该文件包括网络拓扑，允许我们为组织以及属于组织的组件生成一系列证书和密钥。执行示范：</p>
<pre><code>$ cryptogen generate --config=./crypto-config.yaml
</code></pre>

<p>运行后会自动创建一个<code>crypto-config</code>目录，里面有很多密码学文件。在生成的文件中，每个组织都会分配一个根证书(<code>ca-cert</code>)，该证书绑定特殊组件(peer和orderer)到组织。假定每个组织都有一个唯一的CA证书，我们模仿了一个典型的网络，其中每个<a href="http://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#member">成员</a>拥有自己的CA。在Hyperledger Fabric中，实体使用自己的私钥(<code>keystore</code>)对事务和通信进行签名，并用对方的公钥(<code>signcerts</code>)验证签名。<br />
配置文件中<code>Template</code>有个<code>count</code>变量，我们用它来指定每个组织下的peer数量；在我们示例中，每个组织下有两个peer。<code>Users</code>下也有<code>count</code>变量，它表示创建的用户数量。示例如下：</p>
<pre><code class="yaml">  - Name: Org2
    Domain: org2.example.com
    Template:
      Count: 2
    Users:
      Count: 1
</code></pre>

<p>我们在本文不会详述<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">X509证书和PKI</a>。<br />
在<code>crypto-config.yaml</code>文件中，注意<code>OrdererOrgs</code>之下的“Name”, “Domain” and “Specs”参数。网络实体的命名约定是：<code>{{.Hostname}}.{{.Domain}}</code>。例如，排序节点的名称是<code>orderer.example.com</code>，这关联了一个MSP ID <code>Orderer</code>，关于MSP的更多细节参考<a href="https://github.com/wbwangk/wbwangk.github.io/wiki/Fabric%E8%BF%90%E7%BB%B4#%E6%88%90%E5%91%98%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85msp">成员服务提供者(MSP)</a>文档。<br />
在<code>cryptogen</code>生成的加密材料中有管理员的，这里有篇文章<a href="https://github.com/wbwangk/wbwangk.github.io/wiki/Fabric%E7%AC%94%E8%AE%B0#%E5%AF%BB%E6%89%BE%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A7%81%E9%92%A5">寻找管理员的证书和私钥</a>，专门研究了<code>cryptogen</code>生成的管理员的加密材料。  </p>
<h3 id="_5">配置事务生成器<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>工具<code>configtxgen</code>用于生成四个配置工件：
- 排序器(orderer)<code>genesis block</code>
- 通道<code>configuration transaction</code><br />
- 两个<code>anchor peer transactions</code>，每个组织生成一个<br />
关于<code>configtxgen</code>更多细节参考<a href="http://hyperledger-fabric.readthedocs.io/en/latest/configtxgen.html">Channel Configuration (configtxgen)</a>。  </p>
<p>生成的四个工件中的<code>genesis block</code>是排序服务的<a href="#创世区块">创世区块</a>。<a href="#通道">通道</a>的<code>configuration transaction</code>文件在通道创建时被广播到orderer。至于<code>anchor peer transactions</code>，顾名思义，定义组织在这个通道的<a href="#锚点peer">锚点peer</a>。  </p>
<h4 id="_6">工作原理<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<p>Configtxgen会根据文件<code>configtx.yaml</code>定义的配置运行，文件包含了示范网络的定义。其中有三个成员：一个排序器组织(<code>OrdererOrg</code>)和两个Peer组织(<code>Org1</code>和<code>Org2</code>)，每个Peer组织管理和维护了两个peer节点。这个文件还定义了一个联盟(<code>SampleConsortium</code>)，联盟包含了两个peer组织。特别需要注意文件开头的“Profiles”小节。你应该注意到了它有两个唯一的头。一个是排序器创世区块(<code>TwoOrgsOrdererGenesis</code>)，另一个是通道(<code>TwoOrgsChannel</code>)。  </p>
<p>这些头很重要，当生成工件时，它们将作为参数发送。<br />
<em>注释：我们的<code>SampleConsortium</code>联盟定义在系统级profile，然后被通道集profile引用。通道将存在于整个联盟范围。</em>  </p>
<p>这个文件还包含了两个值得注意的附加内容。首先，为每个peer组织(<code>peer0.org1.example.com</code>和<code>peer0.org2.example.com</code>)定义了锚点peer。其次，定义了每个成员的MSP目录地址，这让我们在排序器创世区块中保存了每个组织的根证书。这是一个关键概念。现在与排序服务通信的任何网络实体可以被验证其数字签名了。  </p>
<h3 id="_7">运行工具<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>你可以使用<code>configtxgen</code>和<code>cryptogen</code>工具手工生成证书/密钥和不同的配置工件。或者，你也可以修改<code>byfn.sh</code>脚本来达到你的目的。  </p>
<h4 id="_8">手工生成工件<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<p>你可以参考byfn.sh脚本中的generateCerts函数，里面的命令可以根据<code>crypto-config.yaml</code>文件中定义的网络配置生成证书。  </p>
<p>首先，让我们运行<code>cryptogen</code>工具。它位于<code>bin</code>目录，所以要使用相对路径了执行它（或者修改操作系统的PATH）:</p>
<pre><code>$ ../bin/cryptogen generate --config=./crypto-config.yaml
org1.example.com
org2.example.com
</code></pre>

<p>证书和密钥(即MSP文书)会被输出到<code>crypto-config</code>目录（位于<code>first-network</code>目录之下）。<br />
生成的加密材料主要是管理员的身份证明文件，其中：
- 系统管理员:<code>crypto-config/ordererOrganizations</code>目录下
- 组织管理员：org1组织管理员位于<code>crypto-config/peerOrganizations/org1.example.com</code>目录下
- peer管理员：org1的peer0管理员位于<code>crypto-config/peerOrganizations/org1.example.com/peerspeer0.org1.example.com</code>目录下</p>
<p>下一步，我们需要告诉<code>configtxgen</code>工具到哪里去寻找<code>configtx.yaml</code>文件。需要通过下面的环境变量告诉它($PWD表示当前目录)：</p>
<pre><code>$ export FABRIC_CFG_PATH=$PWD
</code></pre>

<p>然后，我们调用<code>configtxgen</code>工具去生成排序器创世区块：</p>
<pre><code>$ ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
</code></pre>

<p>需要先手工创建目录<code>channel-artifacts</code>，否则上述命令会出错。  </p>
<h4 id="_9">创建一个通道配置事务<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<p>（在Fabric中通道配置信息也保存在区块链中，而区块链的内容是靠事务写入的，所以要新建通道需要创建一个事务。）<br />
下一步，我们需要创建通道事务工件。确保替换<code>$CHANNEL_NAME</code>或设置<code>CHANNEL_NAME</code>为环境变量，然后执行下列指令：</p>
<pre><code>$ export CHANNEL_NAME=mychannel  
$ ../bin/configtxgen -profile TwoOrgsChannel \
 -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
</code></pre>

<p>下一步，我们将在刚刚创建的通道上定义Org1的锚点peer。同样，确保覆盖<code>$CHANNEL_NAME</code>或设置为下面的命令设置环境变量。</p>
<pre><code>$ ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate \
./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
2017-12-07 08:59:42.756 UTC [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration
2017-12-07 08:59:42.762 UTC [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update
2017-12-07 08:59:42.762 UTC [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update
</code></pre>

<p>现在，我们将在同一个通道中定义Org2的锚点peer：</p>
<pre><code>$ ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate \
./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
</code></pre>

<p>总结一下本节，执行了上述一系列命令后，<code>crypto-config</code>目录生成了一些证书和密钥；<code>channel-artifacts</code>下生成了一个创世区块文件和3个事务文件：</p>
<pre><code>$ ls ./channel-artifacts
channel.tx  genesis.block  Org1MSPanchors.tx  Org2MSPanchors.tx
</code></pre>

<p>（执行到这里的时候，就相当于执行了<code>byfn.sh -m generate</code>）  </p>
<h3 id="_10">启动网络<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>我们将使用docker-compose脚本启动我们的网络。docker-compose会使用我们之前下载的docker镜像，用我们之前生成<code>genesis.block</code>(创世区块)引导排序器(orderer)。<br />
在启动网络前，打开<code>docker-compose-cli.yaml</code>文件，注释掉CLI容器的<code>script.sh</code>。让你的<code>docker-compose-cli.yaml</code>文件变成这样：</p>
<pre><code>working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
# command: /bin/bash -c './scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT'
volumes
</code></pre>

<p>如果不注释掉这一样，脚本就会利用CLI命令把网络启动起来了。然而，我们的目的是手工执行这些命令，以便解释这些调用的语法和功能。<br />
CLI默认超时是10000秒。如果你需要容器存在的更久，需要通过设置<code>TIMEOUT</code>环境变量覆盖这一默认值。  </p>
<p>启动网络(确保用命令<code>docker ps -a</code>看不到任何容器)：</p>
<pre><code>$ TIMEOUT=10000 CHANNEL_NAME=$CHANNEL_NAME docker-compose -f docker-compose-cli.yaml up -d
</code></pre>

<p>如果你想看到网络的实时日志，就不要加上<code>-d</code>标志。如果不加<code>-d</code>表示，你需要另外打开一个终端窗口了执行CLI。  </p>
<h4 id="_11">环境变量<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p>为了通过CLI命令让<code>peer0.org1.example.com</code>工作起来，我们需要准备4个环境变量。这些变量之前被“烧入”了<code>peer0.org1.example.com</code>CLI容器中，所以我们不用输入它们就能操作。但如果你需要调用其他peer或orderer，则需要正确的设置这些变量值。查看<code>docker-compose-base.yaml</code>文件可以看到这四个变量的值：</p>
<pre><code># Environment variables for PEER0

CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
</code></pre>

<h4 id="_12">创建和加入通道<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>回想一下上面我们在<a href="#创建一个通道配置事务">创建一个通道配置事务</a>一节中使用<code>configtxgen</code>工具创建通道配置事务。你可以重复那个过程来创建另外的通道配置事务，使用相同或不同的profile参数(在<code>configtx.yaml</code>中定义)传递给<code>configtxgen</code>。你可以重复这一过程，用来在网络中创建其他通道。<br />
用下列命令进入CLI容器：</p>
<pre><code>$ docker exec -it cli bash
root@0d78bb69300d:/opt/gopath/src/github.com/hyperledger/fabric/peer#
</code></pre>

<p>首先进入的是在<code>docker-compose.ymal</code>中定义的<code>working_dir</code>目录。下面用<code>$$</code>表示在容器内的命令行操作。<br />
在之前<a href="#创建一个通道配置事务">创建一个通道配置事务</a>一节中我们创建了通道配置事务工件(&ldquo;channel.txt&rdquo;)，下面我们把它作为创建通道请求的一部分发给orderer。<br />
我们用<code>-c</code>标志指定通道名称，用<code>-f</code>标志指定通道配置事务。在这里它叫<code>channel.txt</code>，然而你可以用其他名字来挂载你自己的通道配置事务。我们又一次在CLI容器内设置<code>CHANNEL_NAME</code>环境变量，所以不用显式地传递这个参数。  </p>
<pre><code>$$ export CHANNEL_NAME=mychannel
$$ export ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
$$ peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f \
./channel-artifacts/channel.tx --tls --cafile $ORDERER_CA
</code></pre>

<p>注意此命令行中的<code>--cafile</code>参数，它是一个指向orderer根CA证书的本地路径，用于验证TLS握手。<br />
命令会返回一个创世区块(<code>&lt;channel-ID.block&gt;</code>)，我们用它加入通道。它里面包含了在<code>channel.tx</code>中定义的配置信息，如果你没有改变过通道名称，该命令将返回一个叫<code>mychannel.block</code>的proto。在当前目录下可以看到这个<code>mychannel.block</code>文件。<br />
现在，让我们把<code>peer0.org1.example.com</code>节点加入通道：</p>
<pre><code>$$ peer channel join -b mychannel.block
</code></pre>

<p>你还可以将其他peer加入通道，方法是修改之前在<a href="#环境变量">环境变量</a>一节中提到的4个环境变量。如果你用<code>env</code>命令查看一下环境变量，会发现那4个环境变量的值都是<code>peer0.org1.example.com</code>对应的。<br />
我们不将每个peer都加入网络，而是将<code>peer0.org2.example.com</code>加入网络，这样我们可以修改通道的锚点peer定义。我们用下面的命令将预先烧制在CLI容器中的4个环境变量替换掉:</p>
<pre><code>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block
</code></pre>

<h4 id="peer">更新锚点peer<a class="headerlink" href="#peer" title="Permanent link">&para;</a></h4>
<p>下面的命令是通道变更，他们会广播到通道定义。本质上，我们会在通道创始区块的上面追加配置信息。注意，我们没有改变创始区块，只是向链中添加了定义锚点peer的delta。<br />
变更通道定义，将<code>peer0.org1.example.com</code>定义为Org1的锚点peer。</p>
<pre><code>$$ peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile $ORDERER_CA
</code></pre>

<p>现在，变更通道定义，将<code>peer0.org2.example.com</code>定义为Org2的锚点peer。注意命令中的4个环境变量用于覆盖默认的<code>peer0.org1.example.com</code>的相关值。</p>
<pre><code>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</code></pre>

<h4 id="_13">安装和实例化链码<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p><em>注意，我们简单实用了一个已有链码。如果想学习链码开发，请参考<a href="../链码教程:链码开发">链码开发</a>一章。</em><br />
应用通过链码与区块链账本交互。我们需要安装链码到那些执行和为事务背书的peer上，并在通道上实例化链码。<br />
首先，安装Go语言示范链码到4个peer节点的某个上。这些命令会将源码放到指定peer的文件系统上。<br />
<em>注意，对于每个链码名称和版本，你只能安装一个版本的源码。源码以链码的名称和版本号为上下文存在于peer的文件系统中，它不关注语言。</em>  </p>
<pre><code>$$ peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/
</code></pre>

<p>下一步在通道上实例化链码。这将在通道上初始化链码、为链码设置背书策略和为目标peer启动一个链码容器。注意<code>-P</code>参数。这是链码的背书策略，用于对链码事务进行验证。<br />
在下面的命令中，你注意到了我们将策略设置为<code>-P "OR ('Org0MSP.member','Org1MSP.member')"</code>。这意味着我们需要从Org1或Org2的peer上获得一个背书。如果把<code>OR</code>改成<code>AND</code>，则表示我们需要两个背书。  </p>
<pre><code>$$ peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -v 1.0 -c '{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}' -P &quot;OR ('Org1MSP.member','Org2MSP.member')&quot;
</code></pre>

<p>关于背书策略的细节可以看到<a href="http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">背书策略</a>。<br />
如果你想更多的peer与账本交互，你需要将它们加入通道，安装同样名字、版本和语言的链码到相应peer的文件系统。一个链码容器被在peer上启动，然后就可以与相应链码交互了。需要知道的是，Node.js镜像的编译相对较慢。<br />
当链码在通道上被实例化后，我们只需传入通道id和链码名称来访问它。  </p>
<h4 id="_14">查询<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<p>让我们查询一下键<code>a</code>的值，以便确认链码已经实例化和状态数据库已经填充。查询语句如下：</p>
<pre><code>$$ peer chaincode query -C $CHANNEL_NAME -n mycc -c '{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}'
Query Result: 100    (其它信息省略)
</code></pre>

<h4 id="inoke">调用(Inoke)<a class="headerlink" href="#inoke" title="Permanent link">&para;</a></h4>
<p>现在让我们把<code>a</code>的10个给<code>b</code>（即a减少10，b增加10）。这个事务会切割一个新区块并更新状态数据库。调用的语法如下：</p>
<pre><code>$$ peer chaincode invoke -o orderer.example.com:7050  --tls --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -c '{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}'
</code></pre>

<p>然后分别查询一下<code>a</code>和<code>b</code>的值：</p>
<pre><code>$$ peer chaincode query -C $CHANNEL_NAME -n mycc -c '{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}'
Query Result: 90    (其它信息省略)
$$ peer chaincode query -C $CHANNEL_NAME -n mycc -c '{&quot;Args&quot;:[&quot;query&quot;,&quot;b&quot;]}'
Query Result: 210    (其它信息省略)
</code></pre>

<h4 id="_15">这演示了什么？<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<p>为了对账本进行读写操作，peer必须安装链码。此外，链码容器并没有启动，直到对链码进行初始化或执行读写事务(如查询<code>a</code>的值)。这些事务促使容器启动。而且，通道中的所有peer会维持一个账本的完全副本，其中包括不可修改、区块中的顺序记录，以及状态数据库(其中维护了当前状态的快照)。这包含没有安装链码的peer（就像上面例子中的<code>peer1.org1.example.com</code>peer)。 最终，链码在安装后可以访问(就像上面例子中的<code>peer1.org2.example.com</code>)，因为它已经被实例化。  </p>
<h4 id="_16">怎么看到这些事务？<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<p>检查CLI docker容器的日志(需要先通过exit命令先退出容器，返回到宿主操作系统):</p>
<pre><code>$ docker logs -f cli
</code></pre>

<p>但，我的cli容器的日志是空的！原因不明</p>
<h4 id="_17">怎么看到链码日志？<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p>用<code>docker logs</code>命令查看不同链码容器的日志，来分别查看各个事务的日志。需要先用<code>docker ps</code>命令找到链码容器id。下面是刚刚测试的链码容器日志：</p>
<pre><code>docker logs 3daea3abfab2
ex02 Init
Aval = 100, Bval = 200
ex02 Invoke
Query Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;100&quot;}
ex02 Invoke
Aval = 90, Bval = 210
ex02 Invoke
Query Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;}
ex02 Invoke
Query Response:{&quot;Name&quot;:&quot;b&quot;,&quot;Amount&quot;:&quot;210&quot;}
</code></pre>

<h3 id="docker-comopse">理解docker-comopse拓扑<a class="headerlink" href="#docker-comopse" title="Permanent link">&para;</a></h3>
<p>BYFN范例提供了两种风格的Docker Compose文件，都是从<code>docker-compose-base.yaml</code>(位于<code>base</code>目录)扩展而来。第一种风格是<code>docker-compose-cli.yaml</code>，提供了一个CLI容器,以及一个orderer和4个peer。我们在这个文章中主要使用这个文件。  </p>
<p><em>注释：本文剩余部分的内容主要讲一个为了SDK设计的docker-compose文件。更多细节参考<a href="https://github.com/hyperledger/fabric-sdk-node">Node SDK库</a>。</em></p>
<p>第二种风格的是<code>docker-compose-e2e.yaml</code>，这个用于使用Node.js SDK进行的端到端测试。为了使用SDK，它的主要不同是包含一个运行fabric-ca服务器的容器。因此，我们可以发送REST请求到组织的CA，用来进行用户的登记(registration)和注册(enrollment)。<br />
如果你想使用<code>docker-compose-e2e.yaml</code>而不运行<code>byfn.sh</code>脚本，需要进行4个小修改。我们需要指出组织CA的私钥。你可以指出私钥在crypto-config目录中的位置。例如，Org1的私钥是路径<code>crypto-config/peerOrganizations/org1.example.com/ca/</code>。这个私钥的文件名是一个以<code>_sk</code>结尾的长哈希值。Org2的私钥路径是<code>crypto-config/peerOrganizations/org2.example.com/ca/</code>。<br />
在<code>docker-compose-e2e.yaml</code>中为ca0和ca1修改<code>FABRIC_CA_SERVER_TLS_KEYFILE</code>变量。你还需要修改启动ca服务器的命令路径。你需要为每个CA容器提供同样的私钥两次。  </p>
<h3 id="couchdb">使用CouchDB<a class="headerlink" href="#couchdb" title="Permanent link">&para;</a></h3>
<p>状态数据库可以从默认(goleveldb)切换到CouchDB。同样的链码函数可以用于CouchDB，然而，当把链码数据建模为JSON后，还可以对状态数据库的数据内容执行丰富而复杂的查询。<br />
使用CouchDB代替默认数据库(goleveldb)，与之前描述相同步骤生成工件，除了启动网络时使用<code>docker-compose-couch.yaml</code>：</p>
<pre><code>CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=&lt;pick_a_value&gt; docker-compose -f docker-compose-cli.yaml -f docker-compose-couch.yaml up -d
</code></pre>

<p>下面的链码<strong>chaincode_example02</strong>将使用CouchDB。  </p>
<p><em>注释：如果你选择了将fabric-couchdb容器的端口映射到主机端口，请确保端口的远程访问是安全的。在开发环境下映射端口使CouchDB REST API可用，并使通过CoutchDB web接口(Fauxton)使数据库可见。在生产环境下进行端口映射要慎重，需要限制从外部访问CouchDB容器的端口。</em>   </p>
<p>你可以用<strong>chaincode_example02</strong>链码访问CouchDB状态数据库，就像前面讲的那样。但为了执行CouchDB特性的查询，你需要使用数据模型为JSON的链码(如<strong>marbles02</strong>)。你可以在<code>fabric/examples/chaincode/go</code>目录找到<strong>marbles02</strong>链码。
我们可以使用相同的步骤创建和加入通道，就像前面在<a href="https://github.com/wbwangk/wbwangk.github.io/wiki/Hyperledger#创建和加入通道">创建和加入通道</a>一节中讲的那样。一旦将peer加入了通道，使用下面的步骤与<strong>marbles02</strong>链码交互：
1. 在<code>peer0.org1.example.com</code>上安装和实例化链码:  </p>
<pre><code>$$ peer chaincode install -n marbles -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles02
$$ peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -v 1.0 -c '{&quot;Args&quot;:[&quot;init&quot;]}' -P &quot;OR ('Org0MSP.member','Org1MSP.member')&quot;
</code></pre>

<ol>
<li>创建一些弹珠并移动它们：</li>
</ol>
<pre><code>$$ peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble1&quot;,&quot;blue&quot;,&quot;35&quot;,&quot;tom&quot;]}'
$$ peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble2&quot;,&quot;red&quot;,&quot;50&quot;,&quot;tom&quot;]}'
$$ peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble3&quot;,&quot;blue&quot;,&quot;70&quot;,&quot;tom&quot;]}'
$$ peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble2&quot;,&quot;jerry&quot;]}'
$$ peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;transferMarblesBasedOnColor&quot;,&quot;blue&quot;,&quot;jerry&quot;]}'
$$ peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;delete&quot;,&quot;marble1&quot;]}'
</code></pre>

<ol>
<li>如果你选择在docker-compse中映射CouchDB端口，你现在就可以通过CouchDB的web接口(Fauxton)查询状态数据库，方法是打开一个浏览器并导航到下列URL：</li>
</ol>
<pre><code>http://localhost:5984/_utils
</code></pre>

<p>你可以看到一个叫<code>mychannel</code>的数据库(或你自己定义的通道名称)和里面的文档数据。</p>
<p><em>注释：你需要更新$CHANNEL_NAME为合适的值</em>   </p>
<p>你可以通过CLI运行一般查询(如读<code>marble2</code>):</p>
<pre><code>$$ peer chaincode query -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;readMarble&quot;,&quot;marble2&quot;]}'
Query Result: {&quot;color&quot;:&quot;red&quot;,&quot;docType&quot;:&quot;marble&quot;,&quot;name&quot;:&quot;marble2&quot;,&quot;owner&quot;:&quot;jerry&quot;,&quot;size&quot;:50}
</code></pre>

<p>你可以查询一个特定弹珠的历史，如<code>marble1</code>:</p>
<pre><code>$$ peer chaincode query -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;getHistoryForMarble&quot;,&quot;marble1&quot;]}'
Query Result: [{&quot;TxId&quot;:&quot;1c3d3caf124c89f91a4c0f353723ac736c58155325f02890adebaa15e16e6464&quot;, &quot;Valu
</code></pre>

<p>你还可以对数据内容执行富文本查询，如查询拥有者<code>jerry</code>的弹珠字段：</p>
<pre><code>peer chaincode query -C $CHANNEL_NAME -n marbles -c '{&quot;Args&quot;:[&quot;queryMarblesByOwner&quot;,&quot;jerry&quot;]}'
Query Result: [{&quot;Key&quot;:&quot;marble2&quot;, &quot;Record&quot;:{&quot;color&quot;:&quot;red&quot;,&quot;docType&quot;:&quot;marble&quot;,&quot;name&quot;:&quot;marble2&quot;,&quot;owner&quot;
</code></pre>

<h3 id="couchdb_1">为什么是CouchDB？<a class="headerlink" href="#couchdb_1" title="Permanent link">&para;</a></h3>
<p>CouchDB是一种NoSQL解决方案。它是一个面向文档的数据库，其中文档字段被存储为键值对。字段可以是简单的键/值对，列表或映射。除了LevelDB支持的keyed/composite-key/key-range查询外，CouchDB还支持完整的富文本查询功能，例如对整个区块链数据的非键查询，因为其数据内容以JSON格式存储，完全可查询。因此，CouchDB可以满足不受LevelDB支持的许多用例的链码，审计和报告要求。</p>
<p>CouchDB还可以增强区块链中合规性和数据保护的安全性。因为它能够通过过滤和屏蔽事务内的属性来实现字段级别的安全性，并且在需要时授权只读权限。  </p>
<p>另外，CouchDB属于CAP定理的AP类型（Availability和Partition Tolerance）。它使用主 - 主复制模型。有关更多信息，请参阅CouchDB文档的“<a href="http://docs.couchdb.org/en/latest/intro/consistency.html"> 最终一致性</a>”页面。但是，在每个Fabric peer下，不存在数据库副本，写入数据库将保证一致性和持久性（非<code>Eventual Consistency</code>）。</p>
<p>CouchDB是Fabric的第一个外部可插入状态数据库，可能也会有其他外部数据库选项。例如，IBM为关系数据库启用区块链。而CP型（一致性和分区容忍）数据库也可能是需要的，以便在没有应用级保证的情况下实现数据一致性。  </p>
<h3 id="_18">一个关于数据持久化的备注<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<p>如果在peer容器或CouchDB容器上需要数据持久性，有一种选择是将docker宿主机中的目录挂载到容器中的相关目录中。例如，您可以在<code>docker-compose-base.yaml</code>文件中的peer容器定义中添加以下两行：</p>
<pre><code>volumes:
 - /var/hyperledger/peer0:/var/hyperledger/production
</code></pre>

<p>对于CouchDB容器，您可以在CouchDB容器定义中添加以下两行：、</p>
<pre><code>volumes:
 - /var/hyperledger/couchdb0:/opt/couchdb/data
</code></pre>

<h3 id="troubleshooting">Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permanent link">&para;</a></h3>
<ul>
<li>总是干净地启动网络。使用下列命令删除共建、密钥、容器和链码镜像：</li>
</ul>
<pre><code>./byfn.sh -m down
</code></pre>

<p><em>注释：如果不删除旧的容器和镜像会报错。</em> </p>
<ul>
<li>如果你看到Docker错误，首先检查docker版本，然后重启docker进程。docker问题往往不好识别。例如，你可能看到的错误是不能找到挂在到容器的加密材料。<br />
如果你想删除镜像重新开始：</li>
</ul>
<pre><code>$ docker rm -f $(docker ps -aq)
$ docker rmi -f $(docker images -q)
</code></pre>

<ul>
<li>如果你在创建、实例化、调用或查询命令中看到错误，确保你的通道名称和链码名称正确。</li>
<li>如果你看到下面的错误：</li>
</ul>
<pre><code>Error: Error endorsing chaincode: rpc error: code = 2 desc = Error installing chaincode code mycc:1.0(chaincode /var/hyperledger/production/chaincodes/mycc.1.0 exits)
</code></pre>

<p>看来你已经有了一个链码镜像（例如<code>dev-peer1.org2.example.com-mycc-1.0</code>或<code>dev-peer0.org1.example.com-mycc-1.0</code>)已经在运行。删除它们重试。</p>
<pre><code>$ docker rmi -f $(docker images | grep peer[0-9]-peer[0-9] | awk '{print $3}')
</code></pre>

<ul>
<li>如果你看到类似下面的内容：</li>
</ul>
<pre><code>Error connecting: rpc error: code = 14 desc = grpc: RPC failed fast due to transport failure
Error: rpc error: code = 14 desc = grpc: RPC failed fast due to transport failure
</code></pre>

<p>确保你正在运行的网络是“1.0.0”镜像并且tag是“latest”。  </p>
<ul>
<li>如果你看到下面的错误：</li>
</ul>
<pre><code>[configtx/tool/localconfig] Load -&gt; CRIT 002 Error reading configuration: Unsupported Config Type &quot;&quot;
panic: Error reading configuration: Unsupported Config Type &quot;&quot;
</code></pre>

<p>说明你没有正确设置环境变量<code>FABRIC_CFG_PATH</code>。configtxgen工具需要这个变量来定位configtx.yaml。返回和执行<code>export FABRIC_CFG_PATH=$PWD</code>，然后重建你的通道工件。<br />
- 使用<code>down</code>选项清理网络：</p>
<pre><code>$ ./byfn.sh -m down
</code></pre>

<ul>
<li>如果你看到一个错误说你仍有活动的端点，则需要prune你的docker网络。这将清除之前的网络，重新启动一个干净的环境：</li>
</ul>
<pre><code>$ docker network prune
</code></pre>

<p>你会看到下列信息：</p>
<pre><code>WARNING! This will remove all networks not used by at least one container.
Are you sure you want to continue? [y/N]
</code></pre>

<p>选择<code>y</code>。</p>
<h3 id="fabric">理解Fabric网络<a class="headerlink" href="#fabric" title="Permanent link">&para;</a></h3>
<p>应用通过API调用智能合约。智能合约托管在网络中，靠名称和版本号识别。例如，智能合约容器的名称是<code>dev-peer0.org1.example.com-fabcar-1.0</code>，其中<code>fabcar</code>是智能合约名称，<code>1.0</code>是智能合约版本号，而<code>dev-peer0.org1.example.com</code>是peer名称。<br />
API可以把SDK访问。SDK封装了应用与智能合约通信的接口，如查询或接收账本更新。这些API使用几个不同的网络地址，接收一些输入参数。智能合约由peer管理员安装，然后按照链码的策略被实例化到通道中。智能合约的实例化流程与普通调用的事务流程相同，背书、排序、生效、提交，之后才能与链码容器交互（智能合约实例化就是链码容器启动）。   </p>
<h4 id="_19">查询<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<p>查询是最简单的调用：一个请求和响应。最常见的查询是向状态数据库查询一个key的当前值(<code>GetState</code>)。然而，<a href="https://github.com/hyperledger/fabric/blob/release/core/chaincode/shim/interfaces.go">链码shim接口</a>允许不同的Get请求，如<code>GetHistoryForKey</code>或<code>GetCreator</code>。<br />
创建查询需要指定一个peer、一个链码、一个通道和一系列输入(如key)和一个可用的链码函数，然后通过API<code>chain.queryByChaincode</code>发送查询到peer。相应的响应值会返回给应用客户端。  </p>
<h4 id="_20">更新<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<p>账本更新开始于应用创建一个事务提议。类似于查询，创建事务请求需要指定一个peer、链码、通道、函数和一系列输入。程序之后会调用API<code>channel.SendTransactionProposal</code>发送事务提议到peer寻求背书。<br />
网络(也就是背书peer(可能多个))会返回一个提议响应，应用使用该响应来创建和签署事务请求。通过调用API<code>channel.sendTransaction</code>，这个事务请求被发送到排序服务。排序服务将事务捆绑入一个区块，并将它发送到通道中的所有peer以求生效(Fabcar网络只有一个peer和一个通道)。<br />
最后应用使用两个事件处理器API：用<code>eh.setPeerAddr</code>连接到peer的事件监听者端口，用<code>eh.registerTxEvent</code>和一个特定事务ID去注册事件。<code>eh.registerTxEvent</code>API使应用可以收到事务结果通知（就是是否生效）。<br />
事务流程图示参考本文的<a href="https://github.com/wbwangk/wbwangk.github.io/wiki/Hyperledger#%E5%85%B1%E8%AF%86%E8%BF%87%E7%A8%8B">共识过程</a>一节。<br />
关于事务流程的更多细节参考<a href="http://hyperledger-fabric.readthedocs.io/en/latest/txflow.html">Transaction Flow</a>。<br />
开始链码编程参考<a href="http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html">Chaincode for Developers</a>。<br />
更多背书策略参考<a href="http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">Endorsement policies</a>。<br />
更多fabric架构信息参考<a href="http://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html">Architecture Explained</a>。 </p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../write_first_app_zh/" class="btn btn-neutral float-right" title="编写第一个应用">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../protocol-spec_zh/" class="btn btn-neutral" title="协议规范"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Hyperledger国际化工作组(yls@chainnova.com)</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/HyperledgerCN/hyperledgerDocs/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../protocol-spec_zh/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../write_first_app_zh/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js"></script>
      <script src="../search/require.js"></script>
      <script src="../search/search.js"></script>

</body>
</html>
